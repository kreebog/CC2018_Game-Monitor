doctype html
html(lang='en')
  head
    include head.pug
  .overlay
  // Page Content
  .container-fluid.text-light
    // Row to organize columns in Bootstrap...
    .row.text-monospace.border-left-0.border-right-0.pt-2(id='game_header' style='border: 1px solid white;line-height:1.5rem;height:85px')
        .ml-3
          img(id='teamLogo')
        .ml-2.mt-2
          span
            span(id='viewTitle' style='color: white;') Game Monitor
            div(id='viewSubTitle') Team Info
    .row
      .card.col-md-6.mx-4.my-4.pb-4.pt-3.px-4.border-0.text-light(id='game')
        div(id='main')
          h5 Please select a game from the list below to get started.
        .d-flex.justify-content-between.border.px-4.my-4.d-none(id="media_controls")
          button(id='media_controls_rew')
            span(class="fa fa-fast-backward" style='font-size:26px;')
          button(id='media_controls_back')
            span(class="fa fa-backward" style='font-size:26px;')
          button(id='media_controls_play')
            span(class="fa fa-play" style='font-size:26px')
          button(id='media_controls_pause')
            span(class="fa fa-pause" style='font-size:26px')
          button(id='media_controls_forward')
            span(class="fa fa-forward" style='font-size:26px')
          button(id='media_controls_ffw')
            span(class="fa fa-fast-forward" style='font-size:26px')
        .d-flex.border-0.px-4.d-none(id='playback-status-message') Loading moves...
        .d-flex.border-0.px-4.py-4.d-none
          select(id="step_switch")
            option(value="step") Step
            option(value="fast") Auto step
      .card.col-md-5.mx-4.my-4.pb-4.pt-3.px-4.border-0.text-light(id='game_action')
        table.table.table-sm.bg_transparent.small.text-center(id='curMovement')
          th(scope='col') Movement Actions
          tr
            td
              div(id="movementBtnGroupUp")
                button(class='movement_btns' id='btn_Jump_N') J
                button(class='movement_btns' id='btn_move_N') M
                button(class='movement_btns' id='btn_look_N') L
                div &#11245;
              div(style="display: flex; justify-content: center;")
                div(id="movementBtnGroupLeft")
                  button(class='movement_btns' id='btn_Jump_W') J
                  button(class='movement_btns' id='btn_move_W') M
                  button(class='movement_btns' id='btn_look_W') L
                  div &#11244;
                div(id="movementBtnGroupRight")
                  div &#11246;
                  button(class='movement_btns' id='btn_look_E') L
                  button(class='movement_btns' id='btn_move_E') M
                  button(class='movement_btns' id='btn_Jump_E') J
              div(id="movementBtnGroupDown") &#11247;
                button(class='movement_btns' id='btn_look_S') L
                button(class='movement_btns' id='btn_move_S') M
                button(class='movement_btns' id='btn_Jump_S') J
              div(id="movementBtnGroupStandWrite")
                button(class='bg-primary' id='btn_stand') Stand
                button(class='bg-primary' id='btn_write') Write
                button(class='bg-primary' id='btn_look') Look
                button(class='bg-primary' id='btn_jump') Jump

        .container(id='gameActivity')
          h3.my-3 Activity
          table.hidden.table.table-sm.bg_transparent.text-center.small(id="activity_table")
            thead 
              th(scope='col') Move
              th(scope='col') Action
              th(scope='col') Direction
              th(scope='col') Cohesion
                tbody
          h3.my-3 Score
          table.table.table-sm.bg_transparent.text-center.small
              th(scope='col') Round
              th(scope='col') Moves
              th(scope='col') Backtracks
              th(scope='col') Bonus
              tr
                td(id='curGame_round') 0
                td(id='curGame_moves') 0
                td(id='curGame_backtracks') 0
                td(id='curGame_bonus') 0
          h3.my-3 Move Result
          .container.small.outcomes-container(id='curGame_outcomes') 
            div(style="display: flex; justify-content: start;")
              div.mr-2 Sight: 
              div.mr-2(id='engramSight')
            div(style="display: flex; justify-content: start;")
              div.mr-2 Sound:
              div.engrams(id='engramSound')
            div(style="display: flex; justify-content: start;")
              div.mr-2 Smell:  
              div.engrams(id='engramSmell')
            div(style="display: flex; justify-content: start;")
              div.mr-2 Touch:
              div.engrams(id='engramTouch')
            div(style="display: flex; justify-content: start;")
              div.mr-2 Taste:
              div.engrams(id='engramTaste')
            div(style="display: flex; justify-content: start;")
              div.mr-2 Outcome: 
              div.mr-2(id='engramOutcome')
    .row
      .col-12(id='games')
        h3 Current Games
        h6(style="text-indent:20px;") There are no games running at the moment, why not start one?
  // Footer
  include foot.pug


 
  // JAVASCRIPT 
  script(src='/views/js/resize.js')
  script.
    
    // gameId and data URLs passed from direct view requests
    let gameViewUrl = '!{gameViewUrl}';
    let gameViewId = '!{gameViewId}';

    // set up global vars
    let gamesList = new Array();
    let curGame = {gameId:0};
    let playerLoc = '#0x0';
    let lastPlayerLoc = '#0x0';
    let lastMoveFetched = 0;
    let movesList = new Array();
    let currentMove = 0;
    let playbackTimer; // used to control auto playback interval timer 
    let scoresList = new Array(); // two dimensional array holding scores for each action in curGame
    let lastNewActionsFound = 0; // track the last time new actions were returned
    let fetchGameDataTimer = -1; // control action fetch timer
    const NO_NEW_ACTIONS_TIMEOUT = 180000; // if no new actions in the last 3 minutes (180k ms), cancel actions poll timer

    // PLAYBACK SPEEDS (1000 = 1 sec)
    // Setting equal to 1ms results in single steps
    let REWIND_SPEED = 1;
    let PLAY_SPEED = 125;
    let FFORWARD_SPEED = 1;

    // default display settings
    $('#media_controls_pause').hide();
    $('#curMovement').hide();
    $('#btn_gameplay_results').hide();

    // polling rates
    const SINGLE_GAME_DATA_POLL = 500;
    const MULTI_GAME_DATA_POLL = 500;


    // Popovers must be initialized with jQuery.
    // Calling twice will disable all popovers in the document:
    $(function () {
      $('#btn_gameplay_results').popover({
        template: '<div id="menu_popover" class="popover" role="tooltip"><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        html: true, 
        placement: 'bottom',
        content: 'btn_gameplay_results content.'
      })
    });


    function resetGamesView(showNoGames, showError) {
      let noGames = '<h3>Current Games</h3>';
      if (showError) {
        noGames += '  <h6 style="text-indent:20px;color:red">Unable to load the list of games - you might need to ask for help!</h6>';
      } else if (showNoGames) {
        noGames += '  <h6 style="text-indent:20px;">There are no games running at the moment, why not start one?</h6>';
      }

      $('#games').html(noGames);
    }

    function resetMazeView() {
      $('#viewTitle').html('Game Monitor');
      $('#main').html('<h5>Please select a game from the list below to get started.</h5>');
    }


    function getActionUrl(buttonId) {
      let ret = '!{baseActionUrl}' + curGame.id + '?act=' + buttonId.split('_')[1] + '&dir=';
      let dir = buttonId.substring(buttonId.length - 1);

      let t = 'none'
      switch (dir) {
        case 'N': t = 'north'; break;
        case 'S': t = 'south'; break;
        case 'E': t = 'east'; break;
        case 'W': t = 'west'; break;
      }

      if (buttonId == 'btn_look' || buttonId == 'btn_jump') t = 'none';

      ret += t;

      return ret;
    }

    // select box for step/fast
    $( "#step_switch" ).change(function() {
      if ($('#step_switch').val() == 'step') {
        FFORWARD_SPEED = 1;
        REWIND_SPEED = 1;
      }
      else {
        FFORWARD_SPEED = 200;
        REWIND_SPEED = 200;
      }
      
    });


    /* Manual movement controls
     */
    var nodes = document.getElementById('curMovement').querySelectorAll('button');
    for(var i = 0 ; i < nodes.length ; i++) {
       
      nodes[i].addEventListener('click', function() {
        $.ajax({url: getActionUrl(this.id), success: function(result) { 
            $('#curGame_round').html(result.score.gameRound);
            $('#curGame_moves').html(result.score.moveCount);
            $('#curGame_backtracks').html(result.score.backtrackCount);
            $('#curGame_bonus').html(result.score.bonusPoints);
            if (result.outcome !== undefined) $('#curGame_outcomes').html(result.outcome.join('<br>'));
            if (result.engram !== undefined) $('#curGame_outcomes').append('<br>' + result.engram.sight + '<br>' + result.engram.sound + '<br>' + result.engram.smell + '<br>' + result.engram.touch + '<br>' + result.engram.taste + '<br>');
            movesList = [];
            playerLoc = '#' + result.location.row + 'x' + result.location.col;
            setPlayerLoc();
            getGameData();
          }
        });
        
      });
    }

    // true = enable
    // false = disable
    function movement(value) {
      value ? $('#curMovement').show() : $('#curMovement').hide();
    }

    // Player Location
    function setPlayerLoc() {
      $(lastPlayerLoc).html('');
      $(playerLoc).html('@');
      lastPlayerLoc = playerLoc.toString();
    }

    // refreshes the current games list
    function refreshGames() {
        $(document).ready(function() {
   
        $.ajax({url: '!{gamesUrl}', success: function(result) {
            if (result.status === undefined && result.length > 0) {
              gamesList = result;
              resetGamesView(false, false);
              gamesList.forEach( function(game, index) { 
                $('#games').append('<div class="col-md-3 col-sm-6 mb-4">' +
                '   <a class="btn" onclick="selectGame(&quot;' + game.gameId + '&quot, &quot;' + game.url + '&quot;)">' + 
                '      <div class="card bg-secondary text-center" style="border:solid 1px black; width:200px;">' + 
                '         <img class="card-img-top" src="/views/images/' + game.team.logo + '" alt="Team Card" style="width:50%;margin-right:auto;margin-left:auto;margin-top:3px">' + 
                '         <h4 class="card-title align-middle text-white font-weight-bold" style="text-shadow:2px 2px #222">' + game.team.name + '</h4>' + 
                '         <div class="card-body bg-danger" style="border:solid 1px black">' + 
                '            <p class="card-text text-white m-0 font-weight-bold" style="text-shadow:1px 1px #222">' + game.mazeStub.seed + '</p>' + 
                '            <p class="card-text text-white m-0" style="text-shadow:1px 1px #222">Round: ' + game.score.gameRound + '</p>' + 
                '            <p class="card-text text-white m-0" style="text-shadow:1px 1px #222">Moves: ' + game.score.moveCount + '</p>' + 
                '         </div>' + 
                '      </div>' + 
                '   </a>' + 
                '</div>');
              });

              if(curGame.gameId == 0) {
                selectGame(gamesList[0].gameId, gamesList[0].url);
                
              }

            } else {
                curGame = {gameId:0};
                gamesList = new Array();
                resetGamesView(true, false);
                resetMazeView();
                movesList = [];
                currentMove = 0;
              }
        }, error: function() {
          resetGamesView(false, true);
        }});
      });
    }

    function selectGame(gameId, gameUrl) {
      console.log('Game Selected: ', gameId);
      if (curGame.gameId == gameId) {
        console.log('Game %s already loaded.', gameId);
        return;
      } else {
        console.log('Loading game: %s', gameId);

        // make the ajax call
        $.ajax({url: gameUrl, success: function(result) {
            curGame = result;
            renderGame();
            lastMoveFetched = 0;
            movesList = [];

            // don't start up the timer if it's already running
            if (fetchGameDataTimer == -1) {
              if (gameViewId != '') {
                console.log('Starting fetchGameDataTimer(getGameViewData) at %sms interval.  Enabling playback...', SINGLE_GAME_DATA_POLL);
                $('#media_controls_pause').css('display', 'block');
                $('#media_controls_play').css('display', 'none');

                fetchGameDataTimer = setInterval(getGameViewData, SINGLE_GAME_DATA_POLL);
              } else {
                console.log('Starting fetchGameDataTimer(getGameData) at %sms interval.', MULTI_GAME_DATA_POLL);
                fetchGameDataTimer = setInterval(getGameData, MULTI_GAME_DATA_POLL);
              }
            }
        }});
      }
    }



    /* function updateEngrams(strArray)
     * @param   engObj - Object containing strings pertaining to each of the 5 senses:
     * 1) sight, 2) sound, 3) smell, 4) touch, 5) taste. 
     *
     * JD - tightened this up a bit
     */
    function updateEngrams(engObj) {
      $('#engramSight').html(engObj.sight.length > 1 ? engObj.sight: ' ');
      $('#engramSound').html(engObj.sound.length > 1 ? engObj.sound: ' ');
      $('#engramSmell').html(engObj.smell.length > 1 ? engObj.smell: ' ');
      $('#engramTouch').html(engObj.touch.length > 1 ? engObj.touch: ' ');
      $('#engramTaste').html(engObj.taste.length > 1 ? engObj.taste: ' ');
    }

    // add outcomes to the engram sight box
    function updateOutcomes(ocObj) {
        $('#engramOutcome').html('');
        for (var x = 0; x < ocObj.length; x++) {
          if (x > 0) $('#engramOutcome').append('<br>');
          $('#engramOutcome').append(ocObj[x]);
        }
    }

    function updateActivity() {

      for (i = currentMove-5; i < currentMove+5; i++ ) {
        if (movesList[currentMove] != undefined) {
        //- h1.badge.badge-primary.badge-warning Move
        //- 
        //- y.appendChild(t);
        //- document.getElementById("myTr").appendChild(y);

        // new row
        let new_table_row = document.createElement("TR");
        new_table_row.setAttribute("id", ("activity_row_" + i.toString()));

        // new cell (move #)
        let new_table_cell_01 = document.createElement("TD");
        var new_text_node = document.createTextNode(movesList[i].score.moveCount);
        new_table_cel_01.appendChild(new_text_node);
        new_table_row.appendChild(new_table_cell_01);

        
        // new cell (action)
        let new_table_cell_02 = document.createElement("TD");
        var new_H1_node_02 = document.createElement("H1");
        var new_text_node_02 = document.createTextNode(movesList[i].action);
        new_H1_node_02.appendChild(new_text_node_02);
        new_H1_node_02.setAttribute("class", ("badge badge-primary badge-warning"));
        new_table_cell_02.appendChild(new_H1_node_02);
        new_table_row.appendChild(new_table_cell_02);


        // new cell (bot cohesion)

        // append row to table
        document.getElementById("activity_table").appendChild(new_table_row);


        // Move 
        // Action
        
        // Direction
        movesList[i].direction;

        // Cohesion - comes in as array movesList.botCohesion
        // unresponsive bots are grayed out. wait... how to display bot cohesion?

        }
      }
    } // end updateActivity()


    /* function updateScores(round, move, back, bonus)
     * @param   round - updates current score >> Round
     * @param   move  - updates current score >> Moves
     * @param   back  - updates current score >> Backtracks
     * @param   bonus - updates current score >> Bonus (points)
     */
    function updateScores(round, move, back, bonus) {
      $('#curGame_round').text(round);
      $('#curGame_moves').text(move);
      $('#curGame_backtracks').text(back);
      $('#curGame_bonus').text(bonus);
    }


    /* Playback controls:
    */
    var media_buttons = document.getElementById('media_controls').querySelectorAll('button');
    for(var i = 0 ; i < media_buttons.length ; i++) {
      media_buttons[i].addEventListener('click', function() {
        $('#media_controls_pause').hide();
        $('#media_controls_play').show();
        switch (this.id) {

          case 'media_controls_rew' : {
                // clear the timer to be
                // sure that we don't get two timers at once
                clearInterval(playbackTimer);
                clearInterval(playNewActionsTimer);
                clearInterval(fetchGameDataTimer);
                
                  tmp = '';
                  while (true) {
                    tmp = getMovePlayback('prev');
                    if (tmp != undefined) {
                      playerLoc = "#" + tmp.row + "x" + tmp.col;
                      setPlayerLoc();

                      // update engrams
                      updateEngrams(movesList[currentMove].engram);

                      // update scores at each interval
                      updateScores(movesList[currentMove].score.gameRound, 
                        movesList[currentMove].score.moveCount, 
                        movesList[currentMove].score.backtrackCount, 
                        movesList[currentMove].score.bonusPoints);

                      updateOutcomes(movesList[currentMove].outcome);
                      renderAction(movesList[currentMove]);
                      
                    }
                    else break;
                  }
                  
              break;
          }
          
          case 'media_controls_back' : {
                // clear the timer to be
                // sure that we don't get two timers at once
                clearInterval(playbackTimer);
                clearInterval(playNewActionsTimer);
                clearInterval(fetchGameDataTimer);

                
                if (REWIND_SPEED == 1) {  // single move per click
                    tmp = getMovePlayback('prev');
                    if (tmp != undefined) {
                      playerLoc = "#" + tmp.row + "x" + tmp.col;
                      setPlayerLoc();

                      // update engrams
                      updateEngrams(movesList[currentMove].engram);

                      // update scores at each interval
                      updateScores(movesList[currentMove].score.gameRound, 
                        movesList[currentMove].score.moveCount, 
                        movesList[currentMove].score.backtrackCount, 
                        movesList[currentMove].score.bonusPoints);
                      
                      updateOutcomes(movesList[currentMove].outcome);
                      renderAction(movesList[currentMove]);

                      
                    }
                }

                else {  // high speed movement
                  let tmp = '';
                  $('#media_controls_pause').show();
                  $('#media_controls_play').hide();
                  playbackTimer = setInterval(function() {
                    console.log('Tick: playbackTimer');
                    tmp = getMovePlayback('prev');
                    if (tmp !== undefined) {

                      // update player location
                      playerLoc = "#" + tmp.row + "x" + tmp.col;
                      setPlayerLoc();

                      // update engrams
                      updateEngrams(movesList[currentMove].engram);

                      // update scores at each interval
                      updateScores(movesList[currentMove].score.gameRound, 
                        movesList[currentMove].score.moveCount, 
                        movesList[currentMove].score.backtrackCount, 
                        movesList[currentMove].score.bonusPoints);
                      
                      updateOutcomes(movesList[currentMove].outcome);
                      renderAction(movesList[currentMove]);

                    } else { // getMovePlayback returned undefined
                      clearInterval(playNewActionsTimer);
                      clearInterval(playbackTimer);
                      clearInterval(fetchGameDataTimer);
                      $('#media_controls_pause').hide();
                      $('#media_controls_play').show();
                    } 
                  }, REWIND_SPEED);
                }  
              break;
          }
          
          case 'media_controls_play' : {
                // clear the timer to be
                // sure that we don't get two timers at once
                clearInterval(playNewActionsTimer);
                clearInterval(playbackTimer);
                clearInterval(fetchGameDataTimer);

                $('#media_controls_play').hide();
                $('#media_controls_pause').show();

                // create a timer to play back the game
                playbackTimer = setInterval( function() {
                  console.log('Tick: Playback Timer');
                  let tmp = getMovePlayback('next');
                  if (tmp !== undefined) {

                  // reset character position to beginning
                  playerLoc = "#" + tmp.row + "x" + tmp.col;
                  setPlayerLoc();

                  // update engrams
                  updateEngrams(movesList[currentMove].engram);

                  // update scores at each interval
                  updateScores(movesList[currentMove].score.gameRound, 
                    movesList[currentMove].score.moveCount, 
                    movesList[currentMove].score.backtrackCount, 
                    movesList[currentMove].score.bonusPoints);
                  updateOutcomes(movesList[currentMove].outcome);
                  renderAction(movesList[currentMove]);
                }
                else {  // getMovePlayback returned undefined
                  clearInterval(playbackTimer);
                }
              }, PLAY_SPEED);
              
              break;
          }

          case 'media_controls_pause' : {
              clearInterval(playNewActionsTimer);
              clearInterval(playbackTimer);
              clearInterval(fetchGameDataTimer);
              $('#media_controls_pause').hide();
              $('#media_controls_play').show();
              break;
          }
          
          case 'media_controls_forward' : {
              clearInterval(playNewActionsTimer);
              clearInterval(playbackTimer);
              clearInterval(fetchGameDataTimer);
              let tmp = '';
                if (FFORWARD_SPEED == 1) {  // single move per click
                    tmp = getMovePlayback('next');
                    if (tmp != undefined) {
                      playerLoc = "#" + tmp.row + "x" + tmp.col;
                      setPlayerLoc();

                      // update engrams
                      updateEngrams(movesList[currentMove].engram);

                      // update scores at each interval
                      updateScores(movesList[currentMove].score.gameRound, 
                        movesList[currentMove].score.moveCount, 
                        movesList[currentMove].score.backtrackCount, 
                        movesList[currentMove].score.bonusPoints);

                      updateOutcomes(movesList[currentMove].outcome);
                      renderAction(movesList[currentMove]);

                    }

                } else {
                      let tmp = '';

                      $('#media_controls_pause').show();
                      $('#media_controls_play').hide();
                      playbackTimer = setInterval(function() {
                        console.log('Tick: playbackTimer');
                        tmp = getMovePlayback('next');
                        if (tmp !== undefined) {
                          playerLoc = "#" + tmp.row + "x" + tmp.col;
                          setPlayerLoc();
                          
                          // update engrams
                          updateEngrams(movesList[currentMove].engram);

                          // update scores at each interval
                          updateScores(movesList[currentMove].score.gameRound, 
                            movesList[currentMove].score.moveCount, 
                            movesList[currentMove].score.backtrackCount, 
                            movesList[currentMove].score.bonusPoints);

                          updateOutcomes(movesList[currentMove].outcome);
                          renderAction(movesList[currentMove]);

                        }
                        else {
                          clearInterval(playbackTimer);
                          $('#media_controls_pause').hide();
                          $('#media_controls_play').show();
                        }
                      }, FFORWARD_SPEED);
                }
              break;
          }
          
          case 'media_controls_ffw' : {
              clearInterval(playNewActionsTimer);
              clearInterval(playbackTimer);
              clearInterval(fetchGameDataTimer);
              let tmp = '';

              while (tmp != undefined) {
                tmp = getMovePlayback('next');
                if (tmp !== undefined) {
                  playerLoc = "#" + tmp.row + "x" + tmp.col;
                  setPlayerLoc();
                  // update engrams
                  updateEngrams(movesList[currentMove].engram);

                  // update scores at each interval
                  updateScores(movesList[currentMove].score.gameRound, 
                    movesList[currentMove].score.moveCount, 
                    movesList[currentMove].score.backtrackCount, 
                    movesList[currentMove].score.bonusPoints);

                  updateOutcomes(movesList[currentMove].outcome);
                  renderAction(movesList[currentMove]);
                }
              }
          }
        }
      });
    } //  end playback controls




    /* Function getMovePlayback(prev | next | current)
     * Get a move in sequence.
     * @param   iteration - move to return, if said move exists
     * @return  object of type {row: y, col: x}
     */
    function getMovePlayback(iteration) {
      switch (iteration) {
        case 'prev' : return (((currentMove-1) in movesList) ? movesList[--currentMove].location : undefined);
        case 'next' : return (((currentMove+1) in movesList) ? movesList[++currentMove].location : undefined);
        case 'current' : return (currentMove !== undefined) ? currentMove : undefined;
      }
    } 



    /* function getGameData()
     * Returns the game stack, including all kinds of neat stuff
     * such as moves and corresponding positions, scores, etc...
     */
    // Get moves stack for current game in multi-game view
    function getGameData() {
      console.log('Tick: getGameData');
      let gameDataURL = 'http://game.code-camp-2018.com/actions/get/' + curGame.id + '?start=' + (lastMoveFetched + 1);
      $.ajax({url: gameDataURL, success: function(result) {
 
        if (result.status === undefined) {

          for (i=0; i < result.length; i++) {
            movesList.push(result[i]);
          }
          lastMoveFetched = movesList.length;
          console.log("Fetched " + lastMoveFetched + " moves...");
          currentMove = movesList.length - 1;

          lastPlayerLoc = playerLoc;
          playerLoc = '#' + movesList[currentMove].location.row.toString() +
                      'x' + movesList[currentMove].location.col.toString();

          setPlayerLoc();
        }

      }, error: function() {
        console.log("Something went wrong when attempting to fetch Game data. Better ask for help.");
      }});
    } // end 


    /**
     * Plays through the given array of actions to catch up
     * to what's happened on the server since the last actions/get poll
     */
    let playNewActionsTimer = -1;
    let newActionPos = 0;
    
    function playNewActions() {

      // stop the getGameViewData fetch timer while this one is running - restart it at the end
      clearInterval(fetchGameDataTimer);

      try {

        $('#playback-status-message').html('Catching up....');

        // async calls might throw this out of whack - if that happens, fix it here.
        if (newActionPos > movesList.length - 1) newActionPos == movesList.length -1;

        // update current move
        currentMove = newActionPos;

        // console.log("newActionPos: %s currentMove: %s movesList.length: %s", newActionPos, currentMove, movesList.length);

        // update player location      
        lastPlayerLoc = playerLoc;
        playerLoc = '#' + movesList[newActionPos].location.row + 'x' + movesList[newActionPos].location.col;
        setPlayerLoc();

        // update scores at each interval
        updateScores(movesList[newActionPos].score.gameRound, 
          movesList[newActionPos].score.moveCount, 
          movesList[newActionPos].score.backtrackCount, 
          movesList[newActionPos].score.bonusPoints);

        // update engrams
        updateEngrams(movesList[newActionPos].engram);
        renderAction(movesList[currentMove]);

        // add outcomes to text display
        if (movesList[newActionPos].outcome !== undefined && movesList[newActionPos].outcome.length > 0) {
          updateOutcomes(movesList[newActionPos].outcome);
        }
      } catch (err) {
        console.error('Error in playNewAction, clearing playNewActionsTimer. Error: %s', err);
        clearInterval(playNewActionsTimer);
      } finally {
          // one more check to make sure we're in bounds... annoying!
          if (newActionPos > movesList.length - 1) newActionPos = movesList.length - 1;

          // restart the getGameViewData timer now that we're caught up
          if (gameViewId != '') {
            //console.log('Starting fetchGameDataTimer(getGameViewData) at %sms interval.', SINGLE_GAME_DATA_POLL);
            fetchGameDataTimer = setInterval(getGameViewData, SINGLE_GAME_DATA_POLL);
          } else {
            //console.log('Starting fetchGameDataTimer(getGameData) at %sms interval.', MULTI_GAME_DATA_POLL);
            fetchGameDataTimer = setInterval(getGameData, MULTI_GAME_DATA_POLL);
          }

        $('#playback-status-message').html('');
      }

      // end playback when actions are exhausted
      if (newActionPos == movesList.length - 1) {
        //console.log('Action playback complete, clearing PlayNewActionsTimer.');
        clearInterval(playNewActionsTimer);
      } else {
        newActionPos++;
      }
    }

    /* function getGameViewData()
     * Returns the game stack, including all kinds of neat stuff
     * such as moves and corresponding positions, scores, etc...
     */
    function getGameViewData() {
      // hide some controls we don't need for gameView Mode
      $('#games').hide();
      $('#step_switch').hide();

      console.log('Tick: getGameViewData() : ' + gameViewUrl);

      // if maze not yet rendered...
      $('#playback-status-message').html('Rendering maze...');
      if (!($('#maze_container').length)) selectGame(gameViewId, gameViewUrl);

      let url_string = 'http://game.code-camp-2018.com/actions/get/' + gameViewId + '?start=' + (lastMoveFetched + 1);
      $('#playback-status-message').html('Loading actions...');
      $.ajax({
        url: url_string, success: function(result) {
          if (result.status === undefined && result.length > 0) {
              //console.log('result::' + JSON.stringify(result));
              lastNewActionsFound = Date.now();

              // add the new moves to the moves list
              for (i = 0; i < result.length; i++) {
                  movesList.push(result[i]);
              }
              
              // start playing new actions with interval calculated to catch up by the time the next new actions poll happens
              newActionPos = lastMoveFetched > 0 ? lastMoveFetched - 1 : 0;
              lastMoveFetched = movesList.length;

              if ($('#media_controls_pause').css('display') != 'none') {
                var newActionPlaybackSpeed = Math.floor(SINGLE_GAME_DATA_POLL / (result.length)) + 5;
                playNewActionsTimer = setInterval(playNewActions, newActionPlaybackSpeed);
              }

            } else {
              currentMove = movesList.length - 1;
              // no new actions - check for wait timeout and cancel timer if needed
              if (Date.now() - lastNewActionsFound > NO_NEW_ACTIONS_TIMEOUT) {
                //console.log('No new actions in last %s minutes, cancelling fetchGameDataTimer.', NO_NEW_ACTIONS_TIMEOUT / 1000 / 60 );
                clearInterval(fetchGameDataTimer);
              }
            }
          } // end success
        , error: function() { console.log("Error in getGameViewData()"); } 
      }); // end ajax call

      // cancel this timer if the game goes into a finished state (states: 0=new, 1=in progress, 2=finished, 3=aborted, 4=error)
      if (curGame.state > 1) {
        $('#playback-status-message').html('GAME ENDED');
        console.log('Game state is %s, cancelling fetchGameDataTimer.', curGame.state);
        clearInterval(fetchGameDataTimer);
      } else {
        $('#playback-status-message').html('');
      }



    } // end getGameData()

    function renderGame() {
      let cells = curGame.maze.cells;
      let maze_width = cells[0].length * 50
      let parent_width = parseInt($('#main').css('width'));

      let cTxt ='';

      // Set the title values
      if (curGame.botId !== '') {
          $('#teamLogo').attr('src', '/views/images/' + curGame.team.logo);
          $('#viewTitle').html(curGame.team.name + ' in ' + curGame.maze.seed);
          
          var botInfo = getBotNameById(curGame.team, curGame.botId) + ' (' + getBotCoderByBotId(curGame.team, curGame.botId) + ')';
          $('#viewSubTitle').html(botInfo);
      } else {
          $('#teamLogo').attr('src', '/views/images/' + curGame.team.logo);
          $('#viewTitle').html(curGame.team.name + ' in ' + curGame.maze.seed);
          var playerNames = '';
          playerNames += curGame.team.bots[0].coder + ' [B1], ';
          playerNames += curGame.team.bots[1].coder + ' [B2], ';
          playerNames += curGame.team.bots[2].coder + ' [B3], ';
          playerNames += curGame.team.bots[3].coder + ' [B4], ';
          if (curGame.team.bots[4].coder != 'NOT USED') playerNames += curGame.team.bots[4].coder + ' [B5]';
          
          $('#viewSubTitle').html(playerNames);
      }

      // Create new maze container and insert into vpGame 
      $('#main').html('');
      $('#main').append('<div id="maze_container"> </div>');
      $('#maze_container').css('width', '500px');
      
      for (row = 0; row < cells.length; row++) {
        // create new row
        let div_row = document.createElement('div');
        div_row.setAttribute("class", "maze_row");
        $('#maze_container').append(div_row);
        div_row.style.width = maze_width + "px";

        for (col = 0; col < cells[0].length; col++) {
          let cId = row + 'x' + col;
          var temp = document.createElement('span');
          temp.setAttribute("id", cId);
          temp.setAttribute("class", "maze_cell");
          div_row.appendChild(temp);

          let cell = cells[row][col];

          let cDiv = $('#' + row + 'x' + col);

          if (!(cell.exits & 1)) cDiv.css('border-top', '2px solid #507091');
          if (!(cell.exits & 2)) cDiv.css('border-bottom', '2px solid #507091');
          if (!(cell.exits & 4)) cDiv.css('border-right', '2px solid #507091');
          if (!(cell.exits & 8)) cDiv.css('border-left', '2px solid #507091');

          if (!!(cell.tags & 1)) cDiv.addClass('start');
          if (!!(cell.tags & 2)) cDiv.addClass('finish');
          
          if (!!(cell.tags & 4)) cDiv.addClass('path');
          if (!!(cell.tags & 16)) cDiv.addClass('lava');
          if (!!(cell.tags & 32)) cDiv.addClass('trap-pit');
          /* if (!!(cell.tags & 64)) cDiv.addClass('trap-bear'); not ready to add bear trap logic yet*/
          if (!!(cell.tags & 256)) cDiv.addClass('trap-flame');
          
        }
      }

      let zoom_value;
      if (maze_width > parent_width) {
        zoom_value = ((parent_width / maze_width)*90).toFixed(6).toString() + "%";
      }
      else {
        zoom_value = "100%";
      }        
      
      $('#media_controls').css('width', '500px');
      $('#media_controls').css('color', 'white')
      resizeContainer('maze_container', zoom_value);
    } // END renderGame()


    /***** code outside functions *****/
    if (gameViewUrl != '') {  // Single game-view mode
        // select game sets fetchGameDataTimer
        selectGame(gameViewId, gameViewUrl);
        lastNewActionsFound = Date.now(); // used to cancel fetchGameDataTimer if no activity
    }

    else {  // multi-game-view mode
      // need to populate the list
      refreshGames();

      // then start the refresh timer
      let gamesListRefreshRate = !{gamesListRefreshRate};
      let gamesListTimer = setInterval(refreshGames, gamesListRefreshRate);
      console.log('Current Games list refreshing every %dms.', gamesListRefreshRate);
      
      // change the rate at which the games list is refreshing
      function changeGamesListRefreshRate(newInterval) {
        if (newInterval < 500){
          console.log('Too fast! Try 500 or more.  Current rate: %dms', gamesListRefreshRate);
          return;
        }
        clearInterval(gamesListTimer);
        gamesListTimer = setInterval(refreshGames, newInterval);
        console.log('Current Games list refresh rate changed from %dms to %dms.', gamesListRefreshRate, newInterval);
        gamesListRefreshRate = newInterval;
      }
    
    }

    // return the name of the bot with the id
    function getBotNameById(team, botId) {
        let bots = team.bots;
        for (let x = 0; x < bots.length; x++) {
            if (bots[x].id == botId) return bots[x].name;
        }
        return 'Mystery Bot';
    }
 
    // return the name of the bot with the id
    function getBotCoderByBotId(team, botId) {
        let bots = team.bots;
        for (let x = 0; x < bots.length; x++) {
            if (bots[x].id == botId) return bots[x].coder;
        }
        return 'Mystery Hacker';
    }

    function renderAction(action) {
      let dir = (action.direction == '' ? 'N/A' : action.direction);
      let act = (action.action == '' ? 'N/A' : action.action);

      let row = '';
      row += '<tr id="__ACT_ROW_' + action.score.moveCount + '">';
      row += '  <td><span>' + action.score.moveCount + '</td></span>';
      row += '  <td><span><h1 class="badge badge-' + getActionBadgeClass(act) + '">' + act + '</td></span>';
      row += '  <td><span><h1 class="badge badge-' + getDirectionBadgeClass(dir) + '">' + dir + '</td></span>';
      row += '  <td><span>';
      row += '    <h1 class="badge bot-badge badge-' + (!action.botCohesion[0] ? 'dark' : getBotBadgeClass(action.botCohesion[0])) + '">B1</h1>';
      row += '    <h1 class="badge bot-badge badge-' + (!action.botCohesion[1] ? 'dark' : getBotBadgeClass(action.botCohesion[1])) + '">B2</h1>';
      row += '    <h1 class="badge bot-badge badge-' + (!action.botCohesion[2] ? 'dark' : getBotBadgeClass(action.botCohesion[2])) + '">B3</h1>';
      row += '    <h1 class="badge bot-badge badge-' + (!action.botCohesion[3] ? 'dark' : getBotBadgeClass(action.botCohesion[3])) + '">B4</h1>';
      row += '    <h1 class="badge bot-badge badge-' + (!action.botCohesion[4] ? 'dark' : getBotBadgeClass(action.botCohesion[4])) + '">B5</h1>';
      row += '  </td></span>';
      row += '</tr>';

      // trim the bottom action off
      if ($('#activity_table tbody').children().length >= 8 ) {
        $('#activity_table tbody tr:last').remove();
      }

      // add a new row at the top
      if ($('#activity_table tbody').children().length == 0) {
        $('#activity_table tbody').append(row);
      }

      $('#activity_table tbody tr:first').before(row);

    }

    function getDirectionBadgeClass(dir) {
        if (dir == 'NORTH') return 'warning';
        if (dir == 'SOUTH') return 'success';
        if (dir == 'EAST') return 'primary';
        if (dir == 'WEST') return 'info';
        return 'dark';
    }

    function getActionBadgeClass(act) {
        if (act == 'MOVE') return 'success';
        if (act == 'LOOK') return 'warning';
        if (act == 'JUMP') return 'danger';
        if (act == 'WRITE') return 'primary';
        return 'dark';
    }

    function getBotBadgeClass(cScore) {
      if (cScore == 0) return 'danger';
      if (cScore < .50) return 'warning';
      if (cScore < 1) return 'primary';
      if (cScore == 1) return 'success';
      return 'info';
    }
